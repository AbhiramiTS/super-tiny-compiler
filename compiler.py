# encoding=utf8

# TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
# T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
# T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E
# T:::::TT:::::::TT:::::THH::::::H     H::::::HHEE::::::EEEEEEEEE::::E
# TTTTTT  T:::::T  TTTTTT  H:::::H     H:::::H    E:::::E       EEEEEE
#         T:::::T          H:::::H     H:::::H    E:::::E
#         T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
#         T:::::T          H:::::::::::::::::H    E:::::::::::::::E
#         T:::::T          H:::::::::::::::::H    E:::::::::::::::E
#         T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE
#         T:::::T          H:::::H     H:::::H    E:::::E
#         T:::::T          H:::::H     H:::::H    E:::::E       EEEEEE
#       TT:::::::TT      HH::::::H     H::::::HHEE::::::EEEEEEEE:::::E
#       T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
#       T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E
#       TTTTTTTTTTT      HHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE
# 
#    SSSSSSSSSSSSSSS UUUUUUUU     UUUUUUUUPPPPPPPPPPPPPPPPP   EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR
#  SS:::::::::::::::SU::::::U     U::::::UP::::::::::::::::P  E::::::::::::::::::::ER::::::::::::::::R
# S:::::SSSSSS::::::SU::::::U     U::::::UP::::::PPPPPP:::::P E::::::::::::::::::::ER::::::RRRRRR:::::R
# S:::::S     SSSSSSSUU:::::U     U:::::UUPP:::::P     P:::::PEE::::::EEEEEEEEE::::ERR:::::R     R:::::R
# S:::::S             U:::::U     U:::::U   P::::P     P:::::P  E:::::E       EEEEEE  R::::R     R:::::R
# S:::::S             U:::::U     U:::::U   P::::P     P:::::P  E:::::E               R::::R     R:::::R
#  S::::SSSS          U:::::U     U:::::U   P::::PPPPPP:::::P   E::::::EEEEEEEEEE     R::::RRRRRR:::::R
#   SS::::::SSSSS     U:::::U     U:::::U   P:::::::::::::PP    E:::::::::::::::E     R:::::::::::::RR
#     SSS::::::::SS   U:::::U     U:::::U   P::::PPPPPPPPP      E:::::::::::::::E     R::::RRRRRR:::::R
#        SSSSSS::::S  U:::::U     U:::::U   P::::P              E::::::EEEEEEEEEE     R::::R     R:::::R
#             S:::::S U:::::U     U:::::U   P::::P              E:::::E               R::::R     R:::::R
#             S:::::S U::::::U   U::::::U   P::::P              E:::::E       EEEEEE  R::::R     R:::::R
# SSSSSSS     S:::::S U:::::::UUU:::::::U PP::::::PP          EE::::::EEEEEEEE:::::ERR:::::R     R:::::R
# S::::::SSSSSS:::::S  UU:::::::::::::UU  P::::::::P          E::::::::::::::::::::ER::::::R     R:::::R
# S:::::::::::::::SS     UU:::::::::UU    P::::::::P          E::::::::::::::::::::ER::::::R     R:::::R
#  SSSSSSSSSSSSSSS         UUUUUUUUU      PPPPPPPPPP          EEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR
# 
# TTTTTTTTTTTTTTTTTTTTTTTIIIIIIIIIINNNNNNNN        NNNNNNNNYYYYYYY       YYYYYYY
# T:::::::::::::::::::::TI::::::::IN:::::::N       N::::::NY:::::Y       Y:::::Y
# T:::::::::::::::::::::TI::::::::IN::::::::N      N::::::NY:::::Y       Y:::::Y
# T:::::TT:::::::TT:::::TII::::::IIN:::::::::N     N::::::NY::::::Y     Y::::::Y
# TTTTTT  T:::::T  TTTTTT  I::::I  N::::::::::N    N::::::NYYY:::::Y   Y:::::YYY
#         T:::::T          I::::I  N:::::::::::N   N::::::N   Y:::::Y Y:::::Y
#         T:::::T          I::::I  N:::::::N::::N  N::::::N    Y:::::Y:::::Y
#         T:::::T          I::::I  N::::::N N::::N N::::::N     Y:::::::::Y
#         T:::::T          I::::I  N::::::N  N::::N:::::::N      Y:::::::Y
#         T:::::T          I::::I  N::::::N   N:::::::::::N       Y:::::Y
#         T:::::T          I::::I  N::::::N    N::::::::::N       Y:::::Y
#         T:::::T          I::::I  N::::::N     N:::::::::N       Y:::::Y
#       TT:::::::TT      II::::::IIN::::::N      N::::::::N       Y:::::Y
#       T:::::::::T      I::::::::IN::::::N       N:::::::N    YYYY:::::YYYY
#       T:::::::::T      I::::::::IN::::::N        N::::::N    Y:::::::::::Y
#       TTTTTTTTTTT      IIIIIIIIIINNNNNNNN         NNNNNNN    YYYYYYYYYYYYY
# 
#         CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPPPPPPPPP   IIIIIIIIIILLLLLLLLLLL             EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR
#      CCC::::::::::::C   OO:::::::::OO   M:::::::M             M:::::::MP::::::::::::::::P  I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::::::::::::R
#    CC:::::::::::::::C OO:::::::::::::OO M::::::::M           M::::::::MP::::::PPPPPP:::::P I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::RRRRRR:::::R
#   C:::::CCCCCCCC::::CO:::::::OOO:::::::OM:::::::::M         M:::::::::MPP:::::P     P:::::PII::::::IILL:::::::LL             EE::::::EEEEEEEEE::::ERR:::::R     R:::::R
#  C:::::C       CCCCCCO::::::O   O::::::OM::::::::::M       M::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E       EEEEEE  R::::R     R:::::R
# C:::::C              O:::::O     O:::::OM:::::::::::M     M:::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E               R::::R     R:::::R
# C:::::C              O:::::O     O:::::OM:::::::M::::M   M::::M:::::::M  P::::PPPPPP:::::P   I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::RRRRRR:::::R
# C:::::C              O:::::O     O:::::OM::::::M M::::M M::::M M::::::M  P:::::::::::::PP    I::::I    L:::::L                 E:::::::::::::::E     R:::::::::::::RR
# C:::::C              O:::::O     O:::::OM::::::M  M::::M::::M  M::::::M  P::::PPPPPPPPP      I::::I    L:::::L                 E:::::::::::::::E     R::::RRRRRR:::::R
# C:::::C              O:::::O     O:::::OM::::::M   M:::::::M   M::::::M  P::::P              I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::R     R:::::R
# C:::::C              O:::::O     O:::::OM::::::M    M:::::M    M::::::M  P::::P              I::::I    L:::::L                 E:::::E               R::::R     R:::::R
#  C:::::C       CCCCCCO::::::O   O::::::OM::::::M     MMMMM     M::::::M  P::::P              I::::I    L:::::L         LLLLLL  E:::::E       EEEEEE  R::::R     R:::::R
#   C:::::CCCCCCCC::::CO:::::::OOO:::::::OM::::::M               M::::::MPP::::::PP          II::::::IILL:::::::LLLLLLLLL:::::LEE::::::EEEEEEEE:::::ERR:::::R     R:::::R
#    CC:::::::::::::::C OO:::::::::::::OO M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
#      CCC::::::::::::C   OO:::::::::OO   M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R
#         CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPP          IIIIIIIIIILLLLLLLLLLLLLLLLLLLLLLLLEEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR
# 
# =======================================================================================================================================================================
# =======================================================================================================================================================================
# =======================================================================================================================================================================
# =======================================================================================================================================================================

# Today we're going to write a compiler together. But not just any compiler... A
# super duper teeny tiny compiler! A compiler that is so small that if you
# remove all the comments this file would only be ~200 lines of actual code.
#
# We're going to compile some lisp-like function calls into some C-like
# function calls.
#
# If you are not familiar with one or the other. I'll just give you a quick intro.
#
# If we had two functions `add` and `subtract` they would be written like this:
#
#                  LISP                      C
#
#   2 + 2          (add 2 2)                 add(2, 2)
#   4 - 2          (subtract 4 2)            subtract(4, 2)
#   2 + (4 - 2)    (add 2 (subtract 4 2))    add(2, subtract(4, 2))
#
# Easy peezy right?
#
# Well good, because this is exactly what we are going to compile. While this
# is neither a complete LISP or C syntax, it will be enough of the syntax to
# demonstrate many of the major pieces of a modern compiler.

# Parsing
# -------
# 
# Parsing typically gets broken down into two phases: Lexical Analysis and
# Syntactic Analysis.
#
# 1. *Lexical Analysis* takes the raw code and splits it apart into these things
#    called tokens by a thing called a tokenizer (or lexer).
#
#    Tokens are an array of tiny little objects that describe an isolated piece
#    of the syntax. They could be numbers, labels, punctuation, operators,
#    whatever.
#
# 2. *Syntactic Analysis* takes the tokens and reformats them into a
#    representation that describes each part of the syntax and their relation
#    to one another. This is known as an intermediate representation or
#    Abstract Syntax Tree.
#
#    An Abstract Syntax Tree, or AST for short, is a deeply nested object that
#    represents code in a way that is both easy to work with and tells us a lot
#    of information.
#
# For the following syntax:
#
#   (add 2 (subtract 4 2))
#
# Tokens might look something like this:
#
#   [
#     { type: 'paren',  value: '('        },
#     { type: 'name',   value: 'add'      },
#     { type: 'number', value: '2'        },
#     { type: 'paren',  value: '('        },
#     { type: 'name',   value: 'subtract' },
#     { type: 'number', value: '4'        },
#     { type: 'number', value: '2'        },
#     { type: 'paren',  value: ')'        },
#     { type: 'paren',  value: ')'        }
#   ]
#
# And an Abstract Syntax Tree (AST) might look like this:
#
#   {
#     type: 'Program',
#     body: [{
#       type: 'CallExpression',
#       name: 'add',
#       params: [{
#         type: 'NumberLiteral',
#         value: '2'
#       }, {
#         type: 'CallExpression',
#         name: 'subtract',
#         params: [{
#           type: 'NumberLiteral',
#           value: '4'
#         }, {
#           type: 'NumberLiteral',
#           value: '2'
#         }]
#       }]
#     }]
#   }

# Transformation
# --------------
#
# The next type of stage for a compiler is transformation. Again, this just
# takes the AST from the last step and makes changes to it. It can manipulate
# the AST in the same language or it can translate it into an entirely new
# language.
#
# Let’s look at how we would transform an AST.
#
# You might notice that our AST has elements within it that look very similar.
# There are these objects with a type property. Each of these are known as an
# AST Node. These nodes have defined properties on them that describe one
# isolated part of the tree.
#
# We can have a node for a "NumberLiteral":
#
#   {
#     type: 'NumberLiteral',
#     value: '2'
#   }
#
# Or maybe a node for a "CallExpression":
#
#   {
#     type: 'CallExpression',
#     name: 'subtract',
#     params: [...nested nodes go here...]
#   }
#
# When transforming the AST we can manipulate nodes by
# adding/removing/replacing properties, we can add new nodes, remove nodes, or
# we could leave the existing AST alone and create an entirely new one based
# on it.
#
# Since we’re targeting a new language, we’re going to focus on creating an
# entirely new AST that is specific to the target language.
#
# Traversal
# ---------
#
# In order to navigate through all of these nodes, we need to be able to
# traverse through them. This traversal process goes to each node in the AST
# depth-first.
#
#   {
#     type: 'Program',
#     body: [{
#       type: 'CallExpression',
#       name: 'add',
#       params: [{
#         type: 'NumberLiteral',
#         value: '2'
#       }, {
#         type: 'CallExpression',
#         name: 'subtract',
#         params: [{
#           type: 'NumberLiteral',
#           value: '4'
#         }, {
#           type: 'NumberLiteral',
#           value: '2'
#         }]
#       }]
#     }]
#   }
#
# So for the above AST we would go:
#
#   1. Program - Starting at the top level of the AST
#   2. CallExpression (add) - Moving to the first element of the Program's body
#   3. NumberLiteral (2) - Moving to the first element of CallExpression's params
#   4. CallExpression (subtract) - Moving to the second element of CallExpression's params
#   5. NumberLiteral (4) - Moving to the first element of CallExpression's params
#   6. NumberLiteral (2) - Moving to the second element of CallExpression's params
#
# If we were manipulating this AST directly, instead of creating a separate AST,
# we would likely introduce all sorts of abstractions here. But just visiting
# each node in the tree is enough.
#
# The reason I use the word “visiting” is because there is this pattern of how
# to represent operations on elements of an object structure.
#
# Visitors
# --------
#
# The basic idea here is that we are going to create a “visitor” object that
# has methods that will accept different node types.
#
#   var visitor = {
#     NumberLiteral() {},
#     CallExpression() {}
#   };
#
# When we traverse our AST we will call the methods on this visitor whenever we
# encounter a node of a matching type.
#
# In order to make this useful we will also pass the node and a reference to
# the parent node.
#
#   var visitor = {
#     'NumberLiteral':  (node, parent) -> {},
#     'CallExpression': (node, parent) -> {}
#   };

#  Code Generation
#  ---------------
# 
#  The final phase of a compiler is code generation. Sometimes compilers will do
#  things that overlap with transformation, but for the most part code
#  generation just means take our AST and string-ify code back out.
# 
#  Code generators work several different ways, some compilers will reuse the
#  tokens from earlier, others will have created a separate representation of
#  the code so that they can print node linearly, but from what I can tell most
#  will use the same AST we just created, which is what we’re going to focus on.
# 
#  Effectively our code generator will know how to “print” all of the different
#  node types of the AST, and it will recursively call itself to print nested
#  nodes until everything is printed into one long string of code.
# 

#  And that's it! That's all the different pieces of a compiler.
# 
#  Now that isn’t to say every compiler looks exactly like I described here.
#  Compilers serve many different purposes, and they might need more steps than
#  I have detailed.
# 
#  But now you should have a general high-level idea of what most compilers look
#  like.
# 
#  Now that I’ve explained all of this, you’re all good to go write your own
#  compilers right?
# 
#  Just kidding, that's what I'm here to help with :P
# 
#  So let's begin...
# 

# 
# ============================================================================
#                                   (/^▽^)/
#                                THE TOKENIZER!
# ============================================================================
# 
# We're gonna start off with our first phase of parsing, lexical analysis, with
# the tokenizer.

# We're just going to take our string of code and break it down into an array
# of tokens.

#   (add 2 (subtract 4 2))   =>   [{ type: 'paren', value: '(' }, ...]
# 
# We start by accepting an input string of code, and we're gonna set up two
# things...



##To create a copy of an object 
import copy
##regular expression library (search pattern)
import re

#lets build a LISP to C compiler!
# from LISP
# i.e (add 2 (subtract 4 2))  
# to C
## add(2, (subtract(4, 2))


#There are 3 parts to a compiler
# 1 PARSING
## a. Lexical Analysis/Tokenization (vocabulary)
## b. Syntactic Analysis/Parsing (grammar)

# 2 TRANSFORMATION
## a. Traversal 
## b. Transform via Traversal 

# 3 CODE GENERATION
## a. Stringify!


#Tokenizer function receives starting input
# i.e (add 2 (subtract 4 2))
def tokenizer(input_expression):
    #A `current` variable for tracking our position in the code like a cursor (iterating through input array ).
    current = 0
    #And a `tokens` array to store computed tokens
    tokens = []
    ##use regex library to create search patterns for
    #letters a,z
    alphabet = re.compile(r"[a-z]", re.I);
    #numbers 1-9
    numbers = re.compile(r"[0-9]");
    #white space
    whiteSpace = re.compile(r"\s");
  

  # We start by creating a `while` loop where we are setting up our `current`
    # variable to be incremented as much as we want `inside` the loop.
    #
    # We do this because we may want to increment `current` many times within a
    # single loop because our tokens can be any length.

    while current < len(input_expression):
        #track position
        char = input_expression[current]

       # Moving on, we're now going to check for whitespace. This is interesting
        # because we care that whitespace exists to separate characters, but it
        # isn't actually important for us to store as a token. We would only throw
        # it out later.
        #
        # So here we're just going to test for existence and if it does exist we're
        # going to just `continue` on.
        if re.match(whiteSpace, char):
            current = current+1
            continue
        # Then what we want to check for is an open parenthesis. This will
        # later be used for `CallExpressions` but for now we only care about the
        # character.
        #
        # We check to see if we have an open parenthesis:
        if char == '(':
            tokens.append({
                'type': 'left_paren',
                'value': '('
            })
            # Then we increment `current`
            current = current+1
            continue
        # Next we're going to check for a closing parenthesis. We do the same exact
        # thing as before: Check for a closing parenthesis, add a new token,
        # increment `current`, and `continue`.
        if char == ')':
            tokens.append({
                'type': 'right_paren',
                'value': ')'
            })
            #continue iterating
            current = current+1
            continue


         # The next type of token is a number. This is different than what we have
        # seen before because a number could be any number of characters and we
        # want to capture the entire sequence of characters as one token.
        #
        #   (add 123 456)
        #        ^^^ ^^^
        #        Only two separate tokens
        #
        # So we start this off when we encounter the first number in a sequence.
        if re.match(numbers, char):
            value = ''
            #nested iteration if a number is multi-num 
            while re.match(numbers, char):
                value += char
                current = current+1
                char = input_expression[current];
            tokens.append({
                'type': 'number',
                'value': value
            })
            continue
        
        # The last type of token will be a `name` token. This is a sequence of
        # letters instead of numbers, that are the names of functions in our lisp
        # syntax.
        #
        #   (add 2 4)
        #    ^^^
        #    Name token
        #
        if re.match(alphabet, char):
            value = ''
            # Again we're just going to loop through all the letters pushing them to
            # a value.
            while re.match(alphabet, char):
                value += char
                current = current+1
                char = input_expression[current]
            tokens.append({
                'type': 'name',
                'value': value
            })
            continue
        #error condition if we find an unknown value in the input
        raise ValueError('UNKNOWN CHARACTER: ' + char);
    return tokens

#The parse function creates an Abstract Syntax Tree given the computed
#tokens from the previous function   
def parser(tokens):
    #keep track of position while iterating
    global current
    current = 0
    #nested walk function for building an abstract syntax tree
    def walk():
        #keep track of position while iterating? 
        global current
        token = tokens[current]
        #if a number is encountered, return a "NumberLiteral" node
        if token.get('type') == 'number':
            current = current + 1
            return {
                'type': 'NumberLiteral',
                'value': token.get('value')
            }
          
        #if open parentheses encountered, return a "CallExpression" node
        if token.get('type') == 'left_paren':
           #skip past the parenthesis, we're not storing that
            current = current + 1
            token = tokens[current]
            #store the name of operation
            node = {
                'type': 'CallExpression',
                'name': token.get('value'),
                'params': []
            }
            #and this node will have child nodes as parameters
            #and input expression can have many nested expressions
            #so we'll use recursion to build a tree of relations!
            current = current + 1
            token = tokens[current]
            #until the expression ends with a closed parens
            while token.get('type') != 'right_paren':
                #recursively add nodes to the params array via the walk function
                node['params'].append(walk());
                token = tokens[current]
            current = current + 1
            return node
        #error if unknown type encountered
        raise TypeError(token.get('type'))
    
    
    #Let's initialize an empty Abstract Syntax Tree
    ast = {
        'type': 'Program',
        'body': []
    }
    #then populate it by calling the walk function
    #until the global current variable reaches the end of the token array
    while current < len(tokens):
        ast['body'].append(walk())
    #return the completed AST
    return ast


#Helper function for the transformer that enables
#traversing our newly created AST
def traverser(ast, visitor):

    #we take the child node (current AST) and parent node (new AST) as
    #inputs
    def traverseArray(array, parent):
       #iterate through every parameter element in our current AST
        for child in array:
            #and traverse each
            traverseNode(child, parent)
    
    ##we again take the child node (current AST) and parent node (new AST) as
    #inputs. 
    def traverseNode(node, parent):
       #this is our highest level traversal function
       #store a reference to the new AST
        method = visitor.get(node['type'])
        if method:
            method(node, parent)
        #if only python had built-in switch statements like JS, lol its all good
        #we can use a series of if statements
        #if its the top level
        if node['type'] == 'Program':
            #traverse the body
            traverseArray(node['body'], node)
        #if its a call expression
        elif node['type'] == 'CallExpression':
            #traverse the nested paramemeters
            traverseArray(node['params'], node)
        #if its a number literal
        elif node['type'] == 'NumberLiteral':
          #break
            0
        else:
          #error for unknown type 
            raise TypeError(node['type'])
    traverseNode(ast, None)

# using our newly created traversal functions,
#we'll transform our exsiting AST
def transformer(ast):
   #letsd define an empty new AST
    newAst = {
        'type': 'Program',
        'body': []
    }
    #we'll copy the old one and fill the new one with it
    oldAst = ast
    ast = copy.deepcopy(oldAst)
    #let's store a reference to the newAST's body in this context property
    ast['_context'] = newAst.get('body')

    #helper function when a call expression is encountered 
    def CallExpressionTraverse(node, parent):
      #create a call expression node
        expression = {
            'type': 'CallExpression',
            'callee': {
                'type': 'Identifier',
                'name': node['name']
            },
            'arguments': []
        }
        #set the current context to its child args
        node['_context'] = expression['arguments']

        #store nested call expression references
        if parent['type'] != 'CallExpression':
            expression = {
                'type': 'ExpressionStatement',
                'expression': expression
            }
        #store the expression in the context property
        parent['_context'].append(expression)

    #helper function used when a number literal is encountered
    #during traversal. We'll just store the relevant node as we encounter it
    #in the context property
    def NumberLiteralTraverse(node, parent):
        parent['_context'].append({
            'type': 'NumberLiteral',
            'value': node['value']
        })
    #traverse through the AST using our helper functions
    #until we've fully populated the new AST
    traverser( ast , {
        'NumberLiteral': NumberLiteralTraverse,
        'CallExpression': CallExpressionTraverse 
    })
    #return the new AST
    return newAst


##last part! Code generation
#a recursive stringify function that iterates
#through the newly created AST, node by node, continually
#building a string output given the values in each node.
def codeGenerator(node):
    if node['type'] == 'Program':
        return '\n'.join([code for code in map(codeGenerator, node['body'])])
    elif node['type'] == 'Identifier':
        return node['name']
    elif node['type'] == 'NumberLiteral':
        return node['value']
    elif node['type'] == 'ExpressionStatement':
        expression = codeGenerator(node['expression']) 
        return '%s;' % expression
    elif node['type'] == 'CallExpression':
        callee = codeGenerator(node['callee']) 
        params = ', '.join([code for code in map(codeGenerator, node['arguments'])])
        return "%s(%s)" % (callee, params)
    else:
        raise TypeError(node['type'])

#finally, let's put it all together
def compiler(input_expression):
    #given an input expression, create a set of tokens
    tokens = tokenizer(input_expression)
    #create an abstract syntax tree given those tokens
    ast    = parser(tokens)
    #create a transformed AST given the existing one
    newAst = transformer(ast)
    #stringify the transformed AST into an output expression
    output = codeGenerator(newAst)
    #return!
    return output

def main():
    #test 
    input = "(add 2 (subtract 4 2))"
    output = compiler(input)
    print(output)


if __name__ == "__main__":
    main()

